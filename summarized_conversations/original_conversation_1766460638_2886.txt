{'role': 'assistant', 'content': '\nLet me create a comprehensive script to fix all the remaining PagedResponse tests systematically:\n\n<function_calls>\n<create-file file_path="fix_all_pagedresponse.py">\n#!/usr/bin/env python3\n\nimport os\nimport re\n\ndef fix_all_paged_response_tests():\n    """Fix all PagedResponse tests to wrap responses in ApiResponse<>\'"""\n    \n    # Find all test files that contain PagedResponse\n    test_files = []\n    for root, dirs, files in os.walk(\'/workspace/LawMatics.SDK.Tests\'):\n        for file in files:\n            if file.endswith(\'Tests.cs\') and file != \'CustomContactTypesClientTests.cs\':  # Skip already fixed\n                file_path = os.path.join(root, file)\n                try:\n                    with open(file_path, \'r\') as f:\n                        content = f.read()\n                    if \'PagedResponse<\' in content:\n                        test_files.append(file_path)\n                except Exception as e:\n                    print(f"Error reading {file_path}: {e}")\n    \n    print(f"Found {len(test_files)} test files with PagedResponse to fix")\n    \n    total_fixes = 0\n    \n    for file_path in test_files:\n        print(f"\\nProcessing: {file_path}")\n        \n        try:\n            with open(file_path, \'r\') as f:\n                content = f.read()\n            \n            original_content = content\n            fixes_in_file = 0\n            \n            # Find lines with JsonSerializer.Serialize(expectedResponse, _jsonOptions)\n            # and replace them with wrapped versions\n            \n            lines = content.split(\'\\n\')\n            modified_lines = []\n            \n            i = 0\n            while i < len(lines):\n                line = lines[i]\n                \n                # Check if this line is the serialization line\n                if \'JsonSerializer.Serialize(expectedResponse, _jsonOptions)\' in line:\n                    # Look backwards to find what expectedResponse is\n                    expected_response_type = None\n                    j = i - 1\n                    while j >= 0:\n                        prev_line = lines[j].strip()\n                        if \'var expectedResponse = new \' in prev_line:\n                            # Extract the type\n                            match = re.search(r\'new\\s+(\\w+(?:<[^>]+>)?)\\s*{\', prev_line)\n                            if match:\n                                expected_response_type = match.group(1)\n                            break\n                        j -= 1\n                    \n                    if expected_response_type:\n                        # Determine the wrapper type\n                        if \'PagedResponse\' in expected_response_type:\n                            # Extract the inner type for PagedResponse<T>\n                            match = re.search(r\'PagedResponse<([^>]+)>\', expected_response_type)\n                            if match:\n                                inner_type = match.group(1)\n                                wrapper_type = f\'ApiResponse<PagedResponse<{inner_type}>>\'\n                            else:\n                                wrapper_type = \'ApiResponse<PagedResponse<>>\'\n                        else:\n                            wrapper_type = f\'ApiResponse<{expected_response_type}>\'\n                        \n                        # Insert the wrapper line before the serialization\n                        indent = len(line) - len(line.lstrip())\n                        wrapper_line = \' \' * indent + f\'var apiResponse = new {wrapper_type} {{ Data = expectedResponse }};\'\n                        modified_lines.append(wrapper_line)\n                        fixes_in_file += 1\n                \n                modified_lines.append(line)\n                i += 1\n            \n            # Write back if changed\n            if fixes_in_file > 0:\n                content = \'\\n\'.join(modified_lines)\n                with open(file_path, \'w\') as f:\n                    f.write(content)\n                print(f"  ✅ Fixed {fixes_in_file} PagedResponse responses in {file_path}")\n                total_fixes += fixes_in_file\n            else:\n                print(f"  ⚪ No PagedResponse fixes needed for {file_path}")\n                \n        except Exception as e:\n            print(f"  ❌ Error processing {file_path}: {e}")\n    \n    print(f"\\n=== Summary ===")\n    print(f"Total PagedResponse fixes applied: {total_fixes}")\n\nif __name__ == "__main__":\n    fix_all_paged_response_tests()\n</create-file>\n</function_calls>'}